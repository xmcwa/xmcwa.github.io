---
title: 数据结构笔记
description: 
slug: data-structure
date: 2023-09-17
image: cover.jpg
categories:
    - programming
    - algorithm
tags:
    - Data Structure
---

## 知识体系

- 元素：被维护东西的最小单元。
- 元素集合：所有元素构成的集合。
- 元素的类型：例如序列中的点，树上的点，平面中的点等。
- 范围：元素集合的子集，一般可以用少量输入来表示。如序列的区间，树链，平面矩形等。
- 静态问题：只有询问。
- 动态问题：需要支持对元素集合的修改及询问。
- 修改：分为单点修改和范围修改，单点修改又分为插入、删除、修改三种。

- $n$ 维空间体系：可以描述静态或动态问题，将元素变为 $n$ 维空间中的点，将范围变为 $n$ 维空间中的正交范围。
- $n$ 维正交范围：在一个 $n$ 维空间中，第 $i$ 维坐标在 $[l_i,r_i]$ 的点集。
- $A\text{-side}$ 的 $n$ 维正交范围：$A$ 为限制的数量。例如某个 $n$ 维正交范围每一维都有两个限制，则这是一个 $2n\text{-side}$ 的 $n$ 维正交范围。
自由度：一般用于描述静态问题，定义为询问时参数的个数。

### 举例

$1$ 维正交范围
- $1\text{-side}$：序列前缀，树的点到根路径。
- $2\text{-side}$：序列区间，树的子树（比区间弱），树的链（比区间强）。

$2$ 维正交范围
- $2\text{-side}$：$2\text{-side}$ 矩形。
- $3\text{-side}$：$3\text{-side}$ 矩形，树的有向邻域。

### 笛卡尔积
例如序列与序列可以做笛卡尔积，第一个序列中的每个元素 $i$ 与另一个序列中的每个元素 $j$ 组合成 $(i,j)$，所有的 $(i,j)$ 所构成的元素集合就是笛卡尔积的结果。类似的，平面与序列，树与序列也可以做笛卡尔积。

### 动态问题转为静态问题
将元素类型与时间轴做笛卡尔积，即维护每个元素每个时刻的值。转换后会升高一维。

## 一些简单数据结构

### 前缀和
一维静态问题：询问前缀半群信息或区间群信息。

### 树状数组
一维动态问题：单点修改，询问前缀群信息。

### 线段树
一维动态问题：区间修改，询问区间半群信息。

### 树套树
$n$ 维动态问题：单点修改，正交范围半群信息。

### K-D Tree
$n$ 维动态问题：正交范围修改，正交范围半群信息。
后面会继续说。

### 可持久化数据结构
可以解决询问强制在线的静态问题（可以看作扫描线过程中每个历史版本都记录了下来）。

## 常见做法

### 差分
可以直接降低正交范围的 $\text{side}$ 数，而且一般不会增大常数，几乎可以无代价降低问题难度。

### 扫描线
将静态的高自由度问题转换为动态第自由度问题

### 莫队
普通一维扫描线可以看作是若干前缀按照右端点排序依次处理问题，而莫队的范围只是将前缀变为普通区间，并改变了排序规则，因此也是一种扫描线。

#### 序列区间莫队
处理双自由度问题，是二维扫描线，复杂度 $O(n\sqrt m)$

#### 双前缀莫队
给定两个序列，莫队维护两个序列各选一个前缀构成的集合信息。在信息支持差分的情况下和序列区间莫队经常互相转换。复杂度 $O(n\sqrt m)$

#### 带修改莫队
因为带修改所以是动态 $2$ 自由度问题，可以转化成静态的 $3$ 自由度问题。复杂度为 $O(nm^{\frac 23})$

#### 矩形莫队
询问为一个矩形范围，是 $4$ 维的莫队，复杂度 $O(nm^{\frac34})$

#### 子树莫队
子树的不删除莫队等价于树上启发式合并，复杂度 $O(n\log n)$ （子树莫队默认 $n=m$）

子树不删除莫队是 $O(n\log n)$，而序列不删除莫队是 $O(n\sqrt n)$。因此子树弱于 $2$ 自由度区间。

#### 树上路径莫队
树上莫队，复杂度 $O(n\sqrt m)$

## 例题一

### CF1000F One Occurrence

#### 题意
给定长为n的序列，m次查询区间中有多少值只出现一次。

#### 做法
1. 显然可以直接莫队，用莫队将原本 $2$ 自由度转换为 $0$ 自由度问题（$0$ 自由度即询问时不带参数），复杂度 $O(n\sqrt m)$
2. 考虑记录每个数 $a_i$ 上一次出现的下标 $pre_i$ 和下一次出现的下标 $nxt_i$，将询问区间看作二维平面上的一个点 $(l,r)$。只有当 $pre_i<l_j\le i$ 且 $i\le r_j<nxt_i$ 时 $i$ 才会对询问 $j$ 产生 $1$ 的贡献，这样就变为了一个矩形加，单点查值的问题。

做法 $2$ 里面有一个反演的小技巧，如果把所有 $(pre_i,nxt_i)$ 放到平面上，是一个单点加，矩形查询的问题；但改为把 $(l,r)$ 放到平面上，问题就变成了矩形加，单点查询。

### P4396 [AHOI2013] 作业

#### 题意
给定长为 $n$ 的序列，求 $[l,r]$ 区间内值在 $[x,y]$ 中不同值的个数。

#### 做法
1. 莫队懒得写了
2. 运用升维的技巧，记录 $a_i$ 上一次出现的位置 $pre_i$，题目变为求 $i\in[l,r],a_i\in[x,y],pre_i<l$ 的点数，这是一个三维 $5$ 自由度的问题，可以用差分降为 $3$ 自由度，然后三维数点即可。

### Bzoj 3489 A simple rmq problem

#### 题意
给出一个长度为 $n$ 的序列，给出 $m$ 个询问，每次问 $[l,r]$ 中只出现过 $1$ 次的数的最大值，或报告无解。本题强制在线。

#### 做法
和 `CF1000F` 一样的套路，记下来 $pre_i$ 和 $nxt_i$，将每个询问看作二维平面上的一个点 $(l,r)$。每次操作变为对 $pre_i<l_j\le i$ 且 $i\le r_j<nxt_i$  的一个矩形取 `max`，然后单点查询。

然而我们发现取 `max` 后不好消除某个值的影响，因此并不能直接用扫描线做。我们可以将这个问题转换为扫描线+区间插入+区间删除+单点取max，这个可以用线段树标记永久化做。

考虑到这题强制在线，这一类扫描线可做的题强制在线后一般都是用可持久化解决。直接将每个节点上的堆可持久化的话空间 $O(n\log^2n)$，不能通过本题。但你发现访问历史节点 `max` 只需要维护一个普通的堆，将历史的 `max` 值都记下来就行了，空间 $O(n\log n)$，可以通过。

如果本题不强制在线有什么简单的做法呢？可以将矩形按值排序，遍历每个矩形，更新矩形内部答案，删点即可。

### UOJ 637 [美团杯2021] A. 数据结构

#### 题意
给一个长为n的序列，m次查询：如果将区间 [l,r] 中所有数都+1，那么整个序列有多少个不同的数？询问间独立，也就是说每次查询后这个修改都会被撤销。

#### 做法
考虑对于每一个值 $x$ 分别计算它对哪些询问有贡献，若一次操作后，$x$ 没有在序列中出现，则需要满足：1. 所有的 $x$ 都在区间中；2. 所有的 $x-1$ 都不在区间中。

我们将每个询问视为平面上的一个点 $(l,r)$，考虑 $x$ 会对哪些点产生贡献。
+ 为满足条件 1，记 $x$ 第一次出现的下标为 $a_x$，最后一次出现下标为 $b_x$，则要满足 $l\le a_x$ 且 $b_x\le r$
+ 要满足条件 2，等价于存在 $x-1$ 某相邻两次出现位置 $i,j$，满足 $i<l,r<j$ 才行。我们枚举$x-1$ 相邻两次出现位置 $i,j$，画出这个矩形$i<l<j$，$i<r<j$，最终平面中有 $\text{出现次数}+1$ 个矩形，这些矩形的并的部分即可满足条件 2。

对每个 $x$，将同时满足两个条件的部分加一，最后单点查询得到答案。

## K-D Tree

树套树本质上是一种 DAG 结构，不能打懒标记。`k-D Tree` 可以实现许多树套树做不到的操作。

以二维的 `2-D Tree` 为例，考虑这样一种分治结构：初始只有一个根节点；对于一个点集，先按照 $x$ 坐标进行排序，按 $x$ 的中位数将点集分为两部分，两部分分别对应一个儿子节点；接下来，对每部分按 $y$ 坐标排序并分为两部分，每部分又分别对应一个节点；循环这两步骤直到点集中只剩一个点。

![](https://cdn.luogu.com.cn/upload/image_hosting/ann6v89a.png)

`k-D Tree` 的复杂度分析类似线段树，以二维为例，我们只需要统计操作矩形每一条边递归次数，乘以 $4$ 就是矩形操作复杂度。每 $2$ 次划分会将点集划分为 $4$ 部分，这条边最多只会递归进其中的 $2$ 部分。因此复杂度 $T(n)=2T(\frac n4)+O(1)$，不难得到 $T(n)=O(\sqrt n)$。

`k-D Tree` 只有在操作范围都是 $k$ 维正交范围时复杂度正确。其它情况（如询问圆形范围，半平面等）随机数据下也很快但可以被卡。

### K-D Tree 乱搞

有时候可以做一些剪枝可以大幅减小 `k-D Tree` 常数，例如求矩形最大值时记录当前 $ans=k$，小于 $k$ 就不递归。

一般还可以乱搞查询奇怪的范围，比如半平面或者圆。

## 例题二

### 区间逆序对

#### 题意
给定长为 $n$ 的序列 $a$，求区间 $[l,r]$ 逆序对个数。

#### 做法
1. 莫队+数据结构 $O(n\sqrt m\log n)$。
2. 用扫描线扫询问的右端点，然后数据结构维护左端点答案。右端每加入一个值，相当于所有 $i<r$ 且 $a_i\ge a_r$ 的元素都加 $1$。用 `k-D Tree` 维护答案，复杂度 $O(n\sqrt n+m)$。

### P3710 方方方的数据结构

#### 题意
1. $\forall i\in[l,r],a_i\leftarrow a_i+x$
2. $\forall i\in[l,r],a_i\leftarrow a_i\times x$
3. 求 $a_p\bmod 998244353$
4. 撤销第 $p$ 个操作

#### 做法
对时间轴分块，对序列建线段树维护可以做到 $O(n\sqrt m\log n)$。

另一种做法，对序列与时间轴做笛卡尔积。维护二维平面，一维是时间一维是序列，处理出每个操作影响的时间范围，则每个操作相当于对序列 $[l,r]$，时间 $[x,y]$ 的矩形做修改，直接 `k-D Tree` 复杂度时 $O(n\sqrt{n^2})=O(n^2)$ 的，但我们可以只处理所有被询问的点，复杂度 $O(n\sqrt n)$。

### 网上看到的题

#### 题意
给定长度为 $n$ 的序列 $a$ 和长度为 $n$ 的 $01$ 序列 $b$，每次操作给定 $x$，将所有 $a_i=x$ 的位置 $b_i\leftarrow b_i\oplus 1$ ，操作后求 $b$ 连续 $1$ 的段数。

#### 做法
向两端放两个 $0$，之后我们统计 $b_i\oplus b_{i+1}=1$ 的个数，然后除以二就是答案。维护这个，我们在平面中插入点 $(a_i,a_{i+1})$，每次修改就是对 $a_i=x$ 和 $a_{i+1}=x$ 两条直线全部异或 $1$，全局查询，可以用 `k-D Tree` 维护。

### 好像是 SOJ 的题

#### 题意
有一个长为 $4^n$ 的数组 $a$
1. 给定 $l,r$，$\forall i\in[l,r],a_i\leftarrow\lfloor\sqrt {a_i}\rfloor$
2. 给定 $l,r,v$，$\forall i\in[l,r],a_i\leftarrow a_i+v$
3. 给定 $l,r$，求 $\sum_{i=l}^ra_i$
4. $\forall i<rev(i),swap(a_i,a_{rev(i)})$，$rev(i)$ 表示 $i$ 二进制逆序的结果，如 $n=2$ 时 $rev(7)=14$

#### 做法
考虑把每个点 $(i,rev(i))$ 放到平面上，用 `k-D Tree` 维护点集，操作 4 就相当于交换两个坐标轴。

考虑如何维护操作 $1$，我们对每个区间记录 $max$ 和 $min$，若某个区间有 $max-min=\sqrt{max}-\sqrt{min}$，则相当于每个数都减去了相同的数，给区间打减法标记即可，否则递归到两个子区间分别处理。

复杂度证明可以考虑势能分析，每次区间加法操作会递归到 $\log n$ 个节点，因此总共会增加 $\log n\cdot\log V$ 的势能，而每次递归到一个节点会花费 $O(1)$ 代价减小 $1$ 势能。

弱化版：Uoj 228. 基础数据结构练习题

### P6783 [Ynoi2008] rrusq

#### 题意
平面上给定大小为 $n$ 的点集 $a$，点有点权，给定 $m$ 个矩形 $b$，有 $q$ 次询问，每次询问 $b_{l,\cdots,r}$ 的矩形并所覆盖的点权值之和。

#### 做法
先考虑把问题弱化到序列上如何做。用扫描线扫询问的右端点 $r$，对于序列中的每个元素，维护它覆盖它的编号最大的区间，设其编号为 $x$，若 $x\ge l$ 则说明他被 $[l,r]$ 的这些区间并覆盖。原问题变为区间染色和求颜色 $\ge l$ 的点权值之和。而这个编号可以颜色段均摊维护。

回到原问题上，显然可以用 `k-D Tree` 处理，但如何用类似颜色段均摊的方法维护编号呢，可以 `update` 时在每个 `k-D` 树节点打标记。如果递归到一个要更新的节点时，这个节点没有标记，那么直接打上标记返回；如果已经有一个标记，覆盖这个标记；如果子节点中还有标记，那么递归回收有标记的节点。这样每个标记只会被回收 $1$ 次。

## 练习
更多数据结构练习在 [这里](/p/note-ds/)